import type { ParseSourceSpan, TmplAstElement } from '@angular/compiler';
import type { TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';
export declare const createESLintRule: <TOptions extends readonly unknown[], TMessageIds extends string, TRuleListener extends TSESLint.RuleListener = TSESLint.RuleListener>({ name, meta, defaultOptions, create, }: Readonly<{
    name: string;
    meta: {
        docs: {
            category: "Best Practices" | "Stylistic Issues" | "Variables" | "Possible Errors";
            description: string;
            recommended: false | "error" | "warn";
            suggestion?: boolean | undefined;
            requiresTypeChecking?: boolean | undefined;
            extendsBaseRule?: string | boolean | undefined;
        };
    } & Omit<TSESLint.RuleMetaData<TMessageIds>, "docs">;
    defaultOptions: Readonly<TOptions>;
    create: (context: Readonly<TSESLint.RuleContext<TMessageIds, TOptions>>, optionsWithDefault: Readonly<TOptions>) => TRuleListener;
}>) => TSESLint.RuleModule<TMessageIds, TOptions, TRuleListener>;
interface ParserServices {
    convertNodeSourceSpanToLoc: (sourceSpan: ParseSourceSpan) => TSESTree.SourceLocation;
    convertElementSourceSpanToLoc: <TMessageIds extends string>(context: TSESLint.RuleContext<TMessageIds, []>, node: TmplAstElement) => TSESTree.SourceLocation;
}
export declare function getTemplateParserServices<TMessageIds extends string, TOptions extends readonly unknown[]>(context: Readonly<TSESLint.RuleContext<TMessageIds, TOptions>>): ParserServices;
/**
 * Utility for rule authors to ensure that their rule is correctly being used with @angular-eslint/template-parser
 * If @angular-eslint/template-parser is not the configured parser when the function is invoked it will throw
 */
export declare function ensureTemplateParser(context: TSESLint.RuleContext<string, readonly unknown[]>): void;
export {};
